[
  "Topic 10\nQuestion #1\nFor this question, refer to the TerramEarth case study. You start to build a new application that uses a few Cloud Functions for\nthe backend. One use case requires a Cloud Function func_display to invoke another Cloud Function func_query. You want\nfunc_query only to accept invocations from func_display. You also want to follow Google's recommended best practices. What\nshould you do? \nA. \nCreate a token and pass it in as an environment variable to func_display. When invoking func_query, include the token in\nthe request. Pass the same token to func_query and reject the invocation if the tokens are different.\nB. \nMake func_query 'Require authentication.' Create a unique service account and associate it to func_display. Grant the\nservice account invoker role for func_query. Create an id token in func_display and include the token to the request when\ninvoking func_query. \nMost Voted\nC. \nMake func_query 'Require authentication' and only accept internal traffic. Create those two functions in the same VPC.\nCreate an ingress firewall rule for func_query to only allow traffic from func_display.\nD. \nCreate those two functions in the same project and VPC. Make func_query only accept internal traffic. Create an ingress\nfirewall for func_query to only allow traffic from func_display. Also, make sure both functions use the same service account.\nCorrect Answer:\n \nB",
  "Topic 10\nQuestion #2\nFor this question, refer to the TerramEarth case study. You have broken down a legacy monolithic application into a few\ncontainerized RESTful microservices. \nYou want to run those microservices on Cloud Run. You also want to make sure the services are highly available with low\nlatency to your customers. What should you do? \nA. \nDeploy Cloud Run services to multiple availability zones. Create Cloud Endpoints that point to the services. Create a\nglobal HTTP(S) Load Balancing instance and attach the Cloud Endpoints to its backend.\nB. \nDeploy Cloud Run services to multiple regions. Create serverless network endpoint groups pointing to the services. Add\nthe serverless NEGs to a backend service that is used by a global HTTP(S) Load Balancing instance. \nMost Voted\nC. \nDeploy Cloud Run services to multiple regions. In Cloud DNS, create a latency-based DNS name that points to the\nservices.\nD. \nDeploy Cloud Run services to multiple availability zones. Create a TCP/IP global load balancer. Add the Cloud Run\nEndpoints to its backend service.\nCorrect Answer:\n \nB",
  "Topic 10\nQuestion #3\nFor this question, refer to the TerramEarth case study. You are migrating a Linux-based application from your private data\ncenter to Google Cloud. The \nTerramEarth security team sent you several recent Linux vulnerabilities published by Common Vulnerabilities and Exposures\n(CVE). You need assistance in understanding how these vulnerabilities could impact your migration. What should you do?\n(Choose two.) \nA. \nOpen a support case regarding the CVE and chat with the support engineer. \nMost Voted\nB. \nRead the CVEs from the Google Cloud Status Dashboard to understand the impact.\nC. \nRead the CVEs from the Google Cloud Platform Security Bulletins to understand the impact. \nMost Voted\nD. \nPost a question regarding the CVE in Stack Overflow to get an explanation.\nE. \nPost a question regarding the CVE in a Google Cloud discussion group to get an explanation.\nCorrect Answer:\n \nAC",
  "Topic 10\nQuestion #4\nFor this question, refer to the TerramEarth case study. TerramEarth has a legacy web application that you cannot migrate to\ncloud. However, you still want to build a cloud-native way to monitor the application. If the application goes down, you want the\nURL to point to a \"Site is unavailable\" page as soon as possible. You also want your Ops team to receive a notification for the\nissue. You need to build a reliable solution for minimum cost. What should you do? \nA. \nCreate a scheduled job in Cloud Run to invoke a container every minute. The container will check the application URL. If\nthe application is down, switch the URL to the \"Site is unavailable\" page, and notify the Ops team.\nB. \nCreate a cron job on a Compute Engine VM that runs every minute. The cron job invokes a Python program to check the\napplication URL. If the application is down, switch the URL to the \"Site is unavailable\" page, and notify the Ops team.\nC. \nCreate a Cloud Monitoring uptime check to validate the application URL. If it fails, put a message in a Pub/Sub queue\nthat triggers a Cloud Function to switch the URL to the \"Site is unavailable\" page, and notify the Ops team. \nMost Voted\nD. \nUse Cloud Error Reporting to check the application URL. If the application is down, switch the URL to the \"Site is\nunavailable\" page, and notify the Ops team.\nCorrect Answer:\n \nC",
  "Topic 10\nQuestion #5\nFor this question, refer to the TerramEarth case study. You are building a microservice-based application for TerramEarth. The\napplication is based on Docker containers. You want to follow Google-recommended practices to build the application\ncontinuously and store the build artifacts. What should you do? \nA. \nConfigure a trigger in Cloud Build for new source changes. Invoke Cloud Build to build container images for each\nmicroservice, and tag them using the code commit hash. Push the images to the Container Registry. \nMost Voted\nB. \nConfigure a trigger in Cloud Build for new source changes. The trigger invokes build jobs and build container images for\nthe microservices. Tag the images with a version number, and push them to Cloud Storage.\nC. \nCreate a Scheduler job to check the repo every minute. For any new change, invoke Cloud Build to build container\nimages for the microservices. Tag the images using the current timestamp, and push them to the Container Registry.\nD. \nConfigure a trigger in Cloud Build for new source changes. Invoke Cloud Build to build one container image, and tag the\nimage with the label 'latest.' Push the image to the Container Registry.\nCorrect Answer:\n \nA",
  "Topic 10\nQuestion #6\nFor this question, refer to the TerramEarth case study. TerramEarth has about 1 petabyte (PB) of vehicle testing data in a\nprivate data center. You want to move the data to Cloud Storage for your machine learning team. Currently, a 1-Gbps\ninterconnect link is available for you. The machine learning team wants to start using the data in a month. What should you\ndo? \nA. \nRequest Transfer Appliances from Google Cloud, export the data to appliances, and return the appliances to Google\nCloud. \nMost Voted\nB. \nConfigure the Storage Transfer service from Google Cloud to send the data from your data center to Cloud Storage.\nC. \nMake sure there are no other users consuming the 1Gbps link, and use multi-thread transfer to upload the data to Cloud\nStorage.\nD. \nExport files to an encrypted USB device, send the device to Google Cloud, and request an import of the data to Cloud\nStorage.\nCorrect Answer:\n \nA"
]